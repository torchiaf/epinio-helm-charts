## Default values for Epinio Helm Chart.
## This is a YAML-formatted file.
## Declare variables to be passed into your templates.

# Fall back email address to receive notifications from the `letsencrypt-production` issuer.
#
# __SUPERCEDED__ by `global.tlsIssuerMail`.
#
# Kept for backward compatibility, here and in the templates.

email: "epinio@suse.com"

image:
  epinio:
    registry: ghcr.io/
    repository: epinio/epinio-server
    tag: ""
  epinio-ui:
    registry: ghcr.io/
    repository: epinio/epinio-ui
    tag: v1.8.1-0.0.1
  bash:
    registry: ghcr.io/
    repository: epinio/epinio-unpacker
    tag: ""
  awscli:
    repository: amazon/aws-cli
    tag: 2.9.14
  skopeo:
    registry: quay.io/
    repository: skopeo/stable
    tag: v1.10
  kubectl:
    repository: rancher/kubectl
    tag: v1.22.6
  builder:
    repository: paketobuildpacks/builder
    tag: full

server:
  # Domain which serves the Rancher UI (to access the API)
  accessControlAllowOrigin: ""
  # increase this value to increase all timeouts by the same factor
  timeoutMultiplier: 1
  # Increase this value to instruct the API server to produce more debug output
  traceLevel: 0
  # The ingressClassName is used to select the ingress controller for apps.
  # If empty ingress.ingressClassName (see below) is used
  ingressClassName: ""
  # Disable tracking of the Epinio and Kubernetes cluster version
  disableTracking: false
  # Name of the Service Account used by the staging job
  stagingServiceAccountName: ""
  # Resources to allocate to the staging job. Default: unbounded
  stagingResourceRequests:
    cpu: ""
    memory: ""

ingress:
  # The ingressClassName is used to select the ingress controller for the server. If empty no class will be added to the ingresses.
  ingressClassName: ""
  # Annotations to add to the API ingress
  # e.g.: --set 'ingress.annotations.nginx\.ingress\.kubernetes\.io/ssl-redirect=false'
  annotations: {}
  # nginxSSLRedirect to controll https->http redirects
  nginxSSLRedirect: "true"

service:
  # -- Annotations to be added to the Epinio service.
  annotations: {}

# The strategy used to deploy the Epinio server.
# If you are using a RWO storage the following will avoid a Multi-Attach error during an `helm upgrade`.
# See https://github.com/epinio/epinio/issues/2253.
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 0
    maxUnavailable: 1

certManagerNamespace: cert-manager

# Connection details for the S3 storage
s3:
  endpoint: s3.amazonaws.com
  bucket: "epinio"
  region: ""
  accessKeyID: ""
  secretAccessKey: ""
  useSSL: true
  # Set it to an existing secret if S3 is using a self signed cert
  certificateSecret: ""

api:
  # Default users
  users:
    - username: admin
      passwordBcrypt: "$2a$10$6bCi5NMstMK781In7JGiL.B44pgoplUb330FQvm6mVXMppbXBPiXS"
      role: admin
    - username: epinio
      passwordBcrypt: "$2a$10$6bCi5NMstMK781In7JGiL.B44pgoplUb330FQvm6mVXMppbXBPiXS"
      role: user
      workspaces:
        - workspace

# Dex subchart values -- None for now, and sub chart disabled
dex:
  # hardcode this, to avoid problems with release name
  fullnameOverride: "dex"
  configSecret:
    create: false
    name: "dex-config"
  ui:
    # secret should be supplied by dex automatically, this is just a fall back
    secret: ""
    # Defaults to https://epinio.{{ .Values.global.domain }}/auth/verify/
    redirectURI: ""
  service:
    # -- Annotations to be added to the Epinio service.
    annotations: {}

# Extra environment variables passed to the epinio-server pod.
# extraEnv:
# - name: MY_ENV_VAR
#   value: "1.0"

# Minio subchart values
minio:
  enabled: true
  # hardcode this, to avoid problems with release name
  fullnameOverride: minio
  existingSecret: minio-creds
  tls:
    enabled: true
    certSecret: minio-tls
    publicCrt: tls.crt
    privateKey: tls.key
  persistence:
    size: 2Gi
  drivesPerNode: 4
  replicas: 1
  resources:
    requests:
      memory: 1Gi
  makeUserJob:
    podAnnotations:
      linkerd.io/inject: disabled

epinioUI:
  enabled: true
  # UI theme, either 'light' or 'dark'
  theme: light
  imagePullPolicy: IfNotPresent
  # API URL of epinio instance, for proxied connections, defaults to http://epinio-server.%s.svc.cluster.local"
  apiURL: ""
  wssURL: ""
  dexURL: ""
  uiURL: ""
  # Skip checking for valid SSL cert when making requests to `EPINIO_API_URL`
  apiSkipSSL: "true"
  logLevel: info
  # Domain that will serve the UI and be the origin of browser requests, used by CORS process
  allowedOrigins: ""
  ingress:
    enabled: false
    # The ingressClassName is used to select the ingress controller. If empty no class will be added to the ingresses.
    ingressClassName: ""
  service:
    # -- Annotations to be added to the service.
    annotations: {}

kubed:
  enabled: true
  fullnameOverride: kubed
  enableAnalytics: false

# s3gw subchart values
s3gw:
  enabled: false
  ingress:
    enabled: false
  ui:
    enabled: false
  serviceName: s3gw
  useExistingSecret: true
  storageSize: 2Gi
  storageClass:
    create: false
    name: ""

containerregistry:
  enabled: true
  image:
    registry:
      repository: registry
      tag: 2.8.1
    nginx:
      repository: nginx
      tag: 1.23.2-alpine
  imagePullPolicy: IfNotPresent
  # The ingressClassName is used to select the ingress controller. If
  # empty no class will be added to the ingresses.
  ingressClassName: ""
  # The certificateSecret is used to load the certificate of the registry in the staging job.
  # The certificate has to be in PEM format within in a 'tls.crt' key (it can be an Opaque secret).
  # It also has to be trusted by the kubelet, and it needs to be added in the cluster as well.
  certificateSecret: ""

serviceCatalog:
  # Enable service catalog service for development
  enableDevServices: true

global:
  dex:
    enabled: true
  # The domain that will be used to access the epinio API server and the registry
  domain: ""
  # Connection details for the container registry.
  # Skip if containerregistry.enabled is true
  registryURL: ""
  registryUsername: "admin"
  registryPassword: "changeme"
  # Used in registry path when pushing -> "external.tld/apps/APPNAME"
  registryNamespace: "apps"
  # The name of the cluster issuer to use.
  # Epinio creates three options: 'epinio-ca', 'letsencrypt-production', and 'selfsigned-issuer'.
  tlsIssuer: "epinio-ca"
  # Email address to receive the certificate notification emails send by the `letsencrypt-production` issuer.
  tlsIssuerEmail: "epinio@suse.com"
  # The URL of the container registry from where to pull container images for the various
  # created Pods. Don't confuse this registry with the "Epinio registry" which is the one
  # where Epinio stores the application images.
  cattle:
    systemDefaultRegistry: ""

codeServer:
  # Default values for code-server.
  # This is a YAML-formatted file.
  # Declare variables to be passed into your templates.

  replicaCount: 1

  image:
    repository: codercom/code-server
    tag: '4.14.1'
    pullPolicy: Always

  # Specifies one or more secrets to be used when pulling images from a
  # private container repository
  # https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry
  imagePullSecrets: []
  #  - name: registry-creds

  nameOverride: ""
  fullnameOverride: ""
  hostnameOverride: ""

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  priorityClassName: ""

  service:
    type: ClusterIP
    port: 8080

  ingress:
    enabled: false
    #annotations:
    #  kubernetes.io/tls-acme: "true"
    #hosts:
    #  - host: code-server.example.loc
    #    paths:
    #      - /
    ingressClassName: ""
    #tls:
    #  - secretName: code-server
    #    hosts:
    #      - code-server.example.loc

  # Optional additional arguments
  extraArgs: []
    # These are the arguments normally passed to code-server; run
    # code-server --help for a list of available options.
    #
    # Each argument and parameter must have its own entry; if you use
    # --param value on the command line, then enter it here as:
    #
    # - --param
    # - value
    #
    # If you receive an error like "Unknown option --param value", it may be
    # because both the parameter and value are specified as a single argument,
    # rather than two separate arguments (e.g. "- --param value" on a line).

  # Optional additional environment variables
  extraVars: []
  #  - name: DISABLE_TELEMETRY
  #    value: true
  #  - name: DOCKER_HOST
  #    value: "tcp://localhost:2375"

  ##
  ## Init containers parameters:
  ## volumePermissions: Change the owner of the persist volume mountpoint to RunAsUser:fsGroup
  ##
  volumePermissions:
    enabled: true
    securityContext:
      runAsUser: 0

  ## Pod Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  ##
  securityContext:
    enabled: true
    fsGroup: 1000
    runAsUser: 1000

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #  cpu: 100m
    #  memory: 1000Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  ## Persist data to a persistent volume
  persistence:
    enabled: true
    ## code-server data Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    # storageClass: "-"
    accessMode: ReadWriteOnce
    size: 10Gi
    annotations: {}
    # existingClaim: ""
    # hostPath: /data

  lifecycle:
    enabled: false
    # postStart:
    #  exec:
    #    command:
    #      - /bin/bash
    #      - -c
    #      - curl -s -L SOME_SCRIPT | bash

  ## Enable an Specify container in extraContainers.
  ## This is meant to allow adding code-server dependencies, like docker-dind.
  extraContainers: |
  # If docker-dind is used, DOCKER_HOST env is mandatory to set in "extraVars"
  #- name: docker-dind
  #  image: docker:19.03-dind
  #  imagePullPolicy: IfNotPresent
  #  resources:
  #    requests:
  #      cpu: 250m
  #      memory: 256M
  #  securityContext:
  #    privileged: true
  #    procMount: Default
  #  env:
  #  - name: DOCKER_TLS_CERTDIR
  #    value: ""
  #  - name: DOCKER_DRIVER
  #    value: "overlay2"

  extraInitContainers: |
  # - name: customization
  #   image: {{ .Values.image.repository }}:{{ .Values.image.tag }}
  #   imagePullPolicy: IfNotPresent
  #   env:
  #     - name: SERVICE_URL
  #       value: https://open-vsx.org/vscode/gallery
  #     - name: ITEM_URL
  #       value: https://open-vsx.org/vscode/item
  #   command:
  #     - sh
  #     - -c
  #     - |
  #       code-server --install-extension ms-python.python
  #       code-server --install-extension golang.Go
  #   volumeMounts:
  #     - name: data
  #       mountPath: /home/coder

  ## Additional code-server secret mounts
  extraSecretMounts: []
    # - name: secret-files
    #   mountPath: /etc/secrets
    #   subPath: private.key # (optional)
    #   secretName: code-server-secret-files
    #   readOnly: true

  ## Additional code-server volume mounts
  extraVolumeMounts: []
    # - name: extra-volume
    #   mountPath: /mnt/volume
    #   readOnly: true
    #   existingClaim: volume-claim
    #   hostPath: ""

  extraConfigmapMounts: []
    # - name: certs-configmap
    #   mountPath: /etc/code-server/ssl/
    #   subPath: certificates.crt # (optional)
    #   configMap: certs-configmap
    #   readOnly: true

  extraPorts: []
    # - name: minecraft
    #   port: 25565
    #   protocol: tcp
